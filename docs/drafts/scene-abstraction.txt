Create a new scene organisation that follows some rules:
- Be extendable from outside AnKi
- Has a simple interface and correct containers
- Be able to fast cast and fast check type (llvm isa<>)

Every scene node has a few properties that are actually interfaces. This interfaces are:

+========================+==================+===================================+=====================+
| Class name             | Base class       | Interface                         | Used                |
+========================+==================+===================================+=====================+
| BaseRenderable         | -                | - getVao(level, type)             | -                   |
|                        |                  | - getVertIdsNum(level, type)      |                     |
|                        |                  | - getModelMatrix(level, type)     |                     |
+------------------------+------------------+-----------------------------------+---------------------+
| Renderable             | BaseRenderable   | - getMaterial                     | PatchNode           |
|                        | VisibleCheckable | - getMaterialRuntime (Mutable)    |                     |
|                        |                  | - getMaterialRuntime (Const)      |                     |
|                        |                  | - renderInMs (its not virtual)    |                     |
+------------------------+------------------+-----------------------------------+---------------------+
| DebugRenderable        | BaseRenderable   | -                                 | Camera, Light       |
+------------------------+------------------+-----------------------------------+---------------------+
| IsRenderable           | BaseRenderable   | getShaderProgram                  | Light               |
+------------------------+------------------+-----------------------------------+---------------------+
| VisiblesContainable    | -                | - getVisiblesInfo                 | Camera, Light       |
|                        |                  | - testFrustum(VisibleCheckable)   |                     |
+------------------------+------------------+-----------------------------------+---------------------+
| VisibleCheckable       | -                | getCollisionShape                 | Camera, Light,      |
|                        |                  |                                   | ModelNode, SkinNode,|
|                        |                  |                                   | PatchNode           |
+------------------------+------------------+-----------------------------------+---------------------+
| RenderablesContainable | -                | - getRenderables                  | ModelNode, SkinNode |
|                        |                  | - nodesInheritCollisionShape      |                     |
+------------------------+------------------+-----------------------------------+---------------------+
| Projectable            | -                | - getViewMatrix                   | Light, Camera       |
|                        |                  | - getProjectionMatrix             |                     |
+------------------------+------------------+-----------------------------------+---------------------+


- VisibleCheckable
	- getCollisionShape (virtual)
	- getVisible
	- setVisible
	- getVisibilityGroup
	
- Renderable
	- material (virtual)
	- getVao(level, passType) (virtual)
	
- IsRenderable
	- getMaterialRuntime (virtual)
	- getVao() (virtual)
	
- VisiblesContainable
	- N * VisibilityGroups with VisibleCheckable
	- testFrustum(VisibleCheckable)
	
- RenderablesContainable
	- N * renderables
	- nodesInheritCollisionShape



PatchNode: Renderable, VisibleCheckable

Light: IsRenderable, VisibleCheckable, VisiblesContainable

Camera: VisibleCheckable, VisiblesContainable

ModelNode: VisibleCheckable, RenderablesContainable



Rendering passes:
	- Level n
		- Color
		- Depth
		- DepthParaboloid	
	- Debug


Other classes:
	

**BaseRenderableInfo**: Contains a class with public interface of:

	- 

**VisiblesInfo**: Contains the lists of:

	- Renderables
		- renderables in MS
		- renderables in BS
	- IsRenderables
		- point lights
		- spot lights
		
==================
Visibility testing
==================

In visibility testing we gather the visible renderables of MS and BS and the lights for IS. Also for every visible light we gather the renderables.

Real flow:

	- Set all nodes to not visible
	- Gather all renderables and lights 
	- For every light that casts shadow get renderables


::

	function test(VisiblesContainable obj)
		for node in nodes
			set node not visible
		endfor
		
		for renderableContainable in all scene's renderableContainables

				if renderableContainable ouside obj frustum 
					break
				endif
			
				set renderableContainable to visible
			
				# eg skin
				if renderableContainable is nodesInheritCollisionShape
					for renderable in renderableContainable's renderables
						set renderable visible
						put renderable in obj container
					endfor
				# eg model node
				else
					for renderable in renderableContainable's renderables
						if renderable inside obj frustum
							put renderable in obj container
						endif
					endfor
				endif
			endif
		endfor
		
		for visiblesContainable in all scene visiblesContainables
			if visiblesContainable inside obj frustum
				put visiblesContainable in obj container
			endfor
		endfor
		
	endfunction

=========
Rendering
=========

::
	function render(VisiblesContainable obj, PassType pt)	
		for renderable obj's renderables
			level = calc from distance of obj and renderable
		
			setupShaderProgram for obj in pt and level
			render using vao of level
		endfor
	endfunction

========
Problems
========

- All properties should contain the world transform
- What happens in a second pass for other camera (for split screen for example). Now the renderings happen sequential so no problem. It may fuck up the visibility vectors










